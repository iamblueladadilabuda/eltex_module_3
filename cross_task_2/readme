Задание 2: fork + poll/epoll/select + timers + IPC  
  
Управление такси.  
Есть опорный пункт – исходное приложение. Запускается один раз и привязано к терминалу, имеет CLI.   
  
В CLI должны быть команды  
* create_driver  
* send_task <pid> <task_timer>  
* get_status <pid>  
* get_drivers  
  
create_driver создает новый процесс (driver), который ожидает команд от CLI, pid процесса будет использоваться для обращения к этому driver.  
  
send_task <pid> <task_timer> создаст задачу для driver номер pid и займет его на task_timer секунд. Если попытаться обратиться к этому driver во  
время выполнения задания с помощью send_task, то driver должен послать ошибку Busy <task_timer>.  
По истечению task_timer секунд driver меняет свое состояние на Available.  
  
get_status <pid> показывает статус driver с номером pid. Может быть Busy <task_timer> либо Available.  
  
get_drivers показывает статусы и pid всех drivers запущенных из этого инстанса CLI.  
  
С таймерами нужно разобраться самостоятельно. Процесс не должен ожидать заданное время в цикле while без полезных действий.  
  
Используются именованные каналы и poll.  

Логика программы.  
Открывается канал для чтения.  
С помощью poll оправшиваем события. Если пришло что-то для чтения - читаем, если нет, то смотрим какую команду выполнить.  
Команду получаем, парся написанную пользователем строку (Parse_Command).  
Create_Driver создаёт нового драйвера и сохраняет его в списке структур драйверов.  
Send_Task даёт драйверу задание. Пока оно выполняется, можно вводить другие команды и они выполнятся.  
Get_Status просматривает поле task_timer структуры Driver и на основе этого выводит информацию (свободен или занят, или вообще не существует).  
Get_Drivers делает то же, что и Get_Status только обо всех драйверах.
